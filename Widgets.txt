PageView( 	//PageView permite a navegação por rolagem de tela
	controller: controlladora,
	physics: NeverScrollableScrollPhysics(), // Serve para tirar a fisíca da Page View, a rolagem de tela
	children: <Widget>[  // filhos para navegação
		Container(color: Colors.yellow),
		Container(color: Colors.blue),
		Container(color: Colors.green)
	]
)

Stack(  // Stack permite você posicionar os filhos aonde desejar com Positioned
	children: <Widget>[
		Positioned(
			top: 8.0, left: 0.0,
			child: Text("olá")
		),
		Positioned(
			bottom: 0.0, left: 0.0,
			child: Text("olá")
		)
	]
)

InkWell(  // semelhante a GestureDetector(), porém com um efeito de click
	child: Container(color: Colors.green),
	onTap: () {}
)

SizedBox(  // semelhante a um Container(), mais usado para definir separadores(padding), ou tamanho de Widgets
	height: 16.0,
	width: 16.0,
)

AspectRatio( // define o tamanho de acordo com a divisão entre larg x alt
	aspectRatio: 0.9,
	child: Container(color: Colors.yellow)
)

TextFormField(  // formatação em real para input
	decoration: InputDecoration(
		prefixText: "R\$",
		border: OutlineInputBorder(),
		isDense: true,
		labelText: label
	),
	inputFormatters: [
		FilteringTextInputFormatter.digitsOnly,
		RealInputFormatter(centavos: false) // pubspec
	]
)

DefaultTabController( // é usado para compartilhar um TabController com um TabBar ou um TabBarView. 
	length: 2, // deve ficar dentro do MaterialApp
	child: Scaffold(
		appBar: AppBar(
			title: Text("olá"),
			bottom: TabBar(
				indicatorColor: Colors.white,
				tabs: <Widget>[
					Tab(icon: Icon(Icons.grid_on)),
					Tab(icon: Icon(Icons.list))
				]
			)
		),
		body: TabBarView(
			physics: NeverScrollableScrollPhysics(),
			children: <Widget>[
				Container(color: Colors.yellow),
				Container(color: Colors.blue),
				Container(color: Colors.green)
			]
		)
	)
)

GridView.builder(
	padding: EdgeInsets.all(4.0),
	itemBuilder: (context, index) {
		return Container("$index"); // responsável por retornar todos os itens, respeitando o itemCount se ultrapassar o valor
	},
	itemCount: 30, // tamanho da grid
	gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
		crossAxisCount: 2,
		mainAxisSpacing: 4.0,
		crossAxisSpacing: 4.0,
		childAspectRatio: 0.65
	)
),

ListView.builder(
	padding: EdgeInsets.all(4.0),
	itemBuilder: (context, index) {
		return Container("$index");
	},
	itemCount: 30
)

CircularProgressIndicator() // loading

FadeInImage.memoryNetwork( // renderiza suavemente as imagens
	placeholder: kTransparentImage, 
	image: 'https://picsum.photos/250?image=9',
	fit: BoxFit.cover
)

Row( // Flexible serve para dividir uma área com flex, no tamanho que vc desejar
	children: <Widget>[ // aqui foi divida em uma linha, duas flexible do mesmo tamanho
		Flexible(
			flex: 1,
			child: Container(Colors.pink)
		),
		Flexible(
			flex: 1,
			child: Container(Colors.amber)
		)
	]
)

CustomScrollView( // retorne ele dentro de uma Stack(children: [CustomScrollView()])
	slivers: <Widget>[  // CustomScrollView(), deve ficar no body do Scaffold
		SliverAppBar(
			floating: true,
			snap: true,
			backgroundColor: Colors.transparent,
			elevation: 0.0,
			flexibleSpace: FlexibleSpaceBar(
				title: const Text("olá"),
				centerTitle: true
			)
		),
		SliverToBoxAdapter( // dentro de slivers não pode usar Widgets "padrões",
			child: Container( // por isso o uso do Widget SliverToBoxAdapter
				height: 200.0,
				alignment: Alignment.center,
				child: CircularProgressIndicator(
					valueColor: AlwaysStoppedAnimation<Color>(Colors.white)
				)
			)
		),
		SliverStaggeredGrid.count(
			crossAxisCount: 2,
			mainAxisSpacing: 1.0,
			crossAxisSpacing: 1.0,
			staggeredTiles: <StaggeredTile>[ // tipo um mapa, definindo quanto vai ocupar de lar x alt
				StaggeredTile.count(2, 2),
				StaggeredTile.count(2, 1),
				StaggeredTile.count(2, 2),
				StaggeredTile.count(2, 1),
				StaggeredTile.count(2, 2),
			],
			children: <Widget>[
				Text('1'),
				Text('2'),
				Text('3'),
				Text('4'),
				Text('5')
			]
		);
	]
)

StreamBuilder<DocumentSnapshot>( //Esse Widget permite observar se acontece alterações nos dados, semelhante ao Future Builder
	stream: Firestore.instance.collection('orders').document(orderId).snapshots(),
	builder: (context, snapshot) { // exemplo com Firebase
		if(!snapshot.hasData) {
			return Center(
				child: CircularProgressIndicator()
			);
		} else {

			int status = snapshot.data['status'];

			return Column();
		}
	}
)

child: ExpansionTile(            // Widget que ao ser cliclado expande sua área,
	title: Text("Texto")   // um clique aparece todas as infos, outro clique esconde
	leading: Icon(Icons.card_giftcard),
	trailing: Icon(Icons.add),
	children: <Widget>[
		Widget que serão escondidos
	]
)

ClipRRect(  // Permite Recortar qualquer Widget
	borderRadius: BorderRadius.horizontal(right: Radius.circular(50)),
	child: SizedBox()
)

BottomSheet(  // Widget que quando clicado em algum Widget tipo GestureDetector ou Button
	onClosing: () {},   // ele sobe uma barra de baixo para cima 
	builder: (_) => Column(
		children: [
			FlatButton(
				child: const Text("Câmera"),
				onPressed: () {}
			),
			FlatButton(
				child: const Text("Galeria"),
				onPressed: () {}
			)
		]
	)
)

LayoutBuilder(  // função de definir o tamanho maximo e minimo que um widget pode ter
	builder: (_, constraints) {
		return Container(
			width: constraints.biggest.width,
			child: Text(homeStore.search)
		);
	}
)